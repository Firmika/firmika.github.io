# 递归&分治

## 基本思想

分治算法的核心思想就是「分而治之」。

大概的流程可以分为三步：分解 -> 解决 -> 合并。

1. 分解原问题为结构相同的子问题。
2. 分解到某个容易求解的边界之后，进行递归求解。
3. 将子问题的解合并成原问题的解。

分治法能解决的问题一般有如下特征：

- 该问题的规模缩小到一定的程度就可以容易地解决。
- 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质，利用该问题分解出的子问题的解可以合并为该问题的解。
- 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。

如果各子问题是不独立的，则分治法要重复地解公共的子问题，也就做了许多不必要的工作。此时虽然也可用分治法，但一般用动态规划较好。

实际上不严谨地来说，动态规划有时也是一种分治思想

（例题：[LeetCode 437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)、[Leetcode 1123. 最深叶节点的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-deepest-leaves/)）



## 例题精选

### [Leetcode 53.最大子数组和 ](https://leetcode.cn/problems/maximum-subarray/)

**题目大意：**在长度为n的数组中找出一个具有最大和的连续子数组。

有更优的DP做法，但该题的分治思想还是很优雅的。

**方法1：分治**

$GetMax(l,r)$表示$num[l:r]$范围内的最大连续子数组之和。

对于$num[l:r]$来说，最大子数组之和的情况主要有三种：

1. 全部位于$num[l:r]$的前半部分

2. 全部位于$num[l:r]$的后半部分

3. 一部分位于前半部分，一部分位于后半部分

   （为防止空数组产生，规定该情况至少有一个元素在前半部分）

因此，运用分治法，$GetMax(l,r)$按照如下顺序执行

1. 计算$GetMax(l,mid)$
2. 计算$GetMax(mid+1,r)$$
3. 计算$Max(i:mid)+Max(mid+1:j),(i<=mid<=j)$
4. 返回1,2,3中的最大值

边界条件：是$l==r$时直接返回当前元素

**时间复杂度：**$O(nlogn)$

**空间复杂度：**$O(n)$



**方法2：动态规划**

**状态设计：**$dp[i]$表示以第i个数结尾的最大连续子数组之和

**状态转移方程：**
$$
dp[i] = max(dp[i-1],0)+num[i]
$$
**初始状态：**$dp[0]=num[0]$

**最终结果：**$max(dp[i])$

**时间复杂度：**$O(n)$

**空间复杂度：**不需要存储每一个$dp[i]$，实时更新答案即可，空间复杂度$O(1)



### [Leetcode 105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

**题目大意：**给出一颗二叉树的前序遍历和中序遍历，构造这颗二叉树。

**方法1：分治**

根据前序遍历顺序来构造二叉树

对于前序遍历中的每一个元素，在中序遍历中找到对应元素，中序遍历中位置左侧是其左子树的所有节点，右侧是右子树的所有节点，递归完成构造即可。

**具体过程：**

设计一个指针$i$指向前序遍历中最新的尚未建立的节点，函数$Build(l,r)$构造$i$指向的节点为根的树，树中节点对应$inorder[l:r]$，不返回值，函数流程如下：

1. 构造值为$preorder[i]$的节点

2. 找到$preorder[i]$在$inorder$中的位置$mid$

   （这一步可以用哈希表预处理，查找时间为$O(1)$）

3. 若$mid-1>=l$，调用$Build(l,mid-1)$构造左子树

4. 若$mid+1<=r$，调用$Build(mid+1,r)$构造右子树

由于以上过程按照前序遍历顺序进行，因此节点构造的顺序与前序遍历序列一一对应。

**时间复杂度：**$O(n)$（哈希表优化，若不用哈希表则为$O(nlogn)$）

**空间复杂度：**$O(n)$（哈希表的空间占用，若不用哈希表则为$O(k),k为树的深度$）

**方法2：迭代**

根据前序+中序、中序＋后序构造二叉树常用方法

**基本思想：**

对于前序遍历中的任意两个连续节点 $u$ 和 $v$，根据前序遍历的流程，我们可以知道  $u$ 和 $v$ 只有两种可能的关系：

1. $v$ 是 $u$ 的左儿子。
2. $v$ 是 $u$ 本身或其祖先的右儿子。

中序遍历的状态可以指向两种情况的一种。

**算法：**

+ 用一个栈$stack$来维护「当前节点的所有还没有考虑过右儿子的祖先节点」，栈顶就是当前节点。用一个指针$index$指向中序遍历的某个位置，初始值为 0。

+ 我们依次枚举前序遍历中除了第一个节点以外的每个节点。如果 index 恰好指向栈顶节点，那么我们不断地弹出栈顶节点并向右移动 index，并将当前节点作为最后一个弹出的节点的右儿子；如果 index 和栈顶节点不同，我们将当前节点作为栈顶节点的左儿子；

+ 无论是哪一种情况，我们最后都将当前的节点入栈。

**时间复杂度：**$O(n)$

**空间复杂度：**$O(k),k为树的深度$



### [Leetcode 109. 有序链表转换二叉搜索树](https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/)

**题目大意：**给出一个升序排列的链表，构造一棵**平衡二叉搜索树**（即对于任意节点，左右子树的高度不超过1）。

**方法1：暴力分治**

**基本思想：**

显然，最终时间复杂度不可能小于$O(n)$，注意到链表的随机访问性能差，可以将链表中的信息先存入数组中。

存入数组后，即可使用分治法构造平衡二叉树。设计函数$BuildTree(l,r)$构造数组$num[l:r]$对应树，流程如下

1. 找到$num[l:r]$最中心节点$num[mid]$，构造该节点为根
2. $BuildTree(l,mid-1)$构造左子树
3. $BuildTree(mid+1,r)$构造右子树

时间复杂度：$O(n)$

空间复杂度：$O(n)$

**方法2：中序遍历**

**基本思想：**

升序排列即二叉搜索树的中序遍历排列，根据中序排列规则倒推构造即可。

**算法：**

与方法1相同，设计函数$BuildTree(l,r)$表示构造$num[l:r]$对应树，但不使用额外数组存储链表，仅在函数走到链表头节点对应位置时才构造相应节点，该顺序可以利用中序遍历实现，流程如下：

1. $Build(l,mid-1)$构造左子树
2. 构造中心节点$num[mid]$为根，该节点的值即为当前链表头，构造后链表后移一位
3. $Build(mid+1,r)$构造右子树

由于链表顺序与中序遍历顺序一致，因此节点的创造顺序必然与链表顺序一致。

**时间复杂度：**$O(n)$

**空间复杂度：**$O(logn)$（平衡二叉树高度，即递归的深度）

（虽然但是好像最终测试数据太小了被暴力法暴揍了？）